\section{Threats to Validity}

\paragraph{Underapproximation of performance impact}
The amount of time that can be optimized by either increasing the list of intrinsics or method inlining is an underapproximation of the total optimizable time.
We do not consider effects of optimizations on another compiler optimizations.
For example, if a method is inlined on a column used to partition data, the inlining would not only trigger more C++ generation, it would also enable filter promotion~\cite{}.
Understanding the impact of inlining on another compiler optimizations is left for future work.

\paragraph{Assumptions for static analysis}
Our static analysis detects sources of C\# code based on several assumptions.
For example, we use naming conventions when pruning generated methods in C\# implementation of managed operators.
A user can potentially call some of these methods in the script, meaning that we would skip a valuable source of user-written C\# code.
However, in practice, such methods are not used in the context of big-data jobs and our manual exploration of many SCOPE scripts illustrates that our assumptions hold.

\paragraph{Challenges for implementing more intrinsics}
We discuss the relevance of providing C++ implementation for more .NET Framework methods.
However, providing C++ translation for some of these methods poses several challenges.
For example, memory management in C\# is very different because it has a garbage collector, while C++ does not.
Another challenge is related to different string encodings in C\# and C++ runtimes, and for some corner cases, there is no clear one-to-one mapping.
However, increasing the list of intrinsics would certainly bring significant performance benefits in SCOPE jobs, and there is a clear motivation for future work to address this problem.  
