\section{Background}
Many (all?) ``Big Data" systems are actually a mixture of languages \cite{}.
In general, we categorize them as comprising a {\it relational} part and a {\it non-relational} part.
The former is some variant of SQL \cite{}, i.e., a declarative data-flow language that expresses how data flows
from inputs to outputs (both usually being relational tables) through a series of data-parallel operators
such as filters, projections, and various types of joins.
The non-relational part is expressed in an imperative language, like C\#, Java, Scala, or Python \cite{}.

The relational aspect is crucial: it is what enables the automatic parallelization for efficiently scaling out to
arbitrary amounts o data.
Big data systems often assume that the non-relational part was written carefully enough so that it does not
violate these assumptions: i.e., programmers must write their non-relational logic to be deterministic and insensitive
to the ordering of the input.

\subsection{Scope Language}
SCOPE \cite{} is a Big Data system used internally within Microsoft.
However it is transitioning into an external offering as U-SQL \cite{}.
Its relational part is very similar to SQL, enough so that we will ignore any differences.
The non-relational part is C\# \cite{}.
This means that all expressions in a SCOPE program (aka {\it script}) are written as C# expressions.
In addition, SCOPE allows user-defined functions (written as C\# methods) and user-defined operators
(written as C\# classes).

\subsubsection{Execution of a Scope Script}
A SCOPE script defines a directed acyclic graph (DAG) where each vertex is a set of operators implemented on the
same physical (or virtual) machine. We use the term {\it node} for the physical or virtual machine that a
vertex is implemented on.
The edges of the DAG are communication channels that use a high-speed communication network between nodes.
The operators within a vertex are the end product of a very sophisticated optimizer \cite{}; expressions written
within a certain construct in the script may end up being executed in vertices that do not correspond to the
construct in a simple manner.
For instance, a sub-expression from a filter may be {\it promoted} into a vertex which extracts an input
table from a data source, whereas the rest of the filter may be in a vertex that is many edges distant from
the input layer.

\subsection{Running C++ vs. C\# Vertex}
The SCOPE compiler generates both C++ and C\# operators for the same source-level construct.
Each operator, however, must execute either entirely in C\# or C++: mixed code is not provided for.
Thus, when possible, the C++ operator is preferred because the data layout in stored data uses C++ data structures.
Thus, for example, a simple projection of a subset of the columns can be done entirely
without using the .NET Runtime.
But when a script contains a C\# expression, such as in Figure~\ref{example:SimpleFilter}, then
each row in the input table must be converted to a C\# representation, i.e., a C\# object representing
the row must be created.
Then the C\# expression can be evaluated in the .NET Runtime.

Because this can be inefficient, the SCOPE runtime contains C++ functions that are semantically
equivalent to a subset of the .NET Framework methods that are frequently used; these are called
{\it intrinsics}.
The SCOPE compiler then emit calls to the (C++) intrinsics in the C++ generated operator, which is
then used at runtime in preference to the C\# generated operator.
(As opposed to using {\it interop} to execute native code from within the .NET Runtime.)


